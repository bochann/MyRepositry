public class DBSaveManager extends SQLiteOpenHelper {    private static String DB_NAME = "omocha_save";    private static String DB_NAME_ASSET = "omocha_save.db";    private final File databasePath;    private final Context mContext;    public DBSaveManager(Context context) {        super(context, DB_NAME, null, 1);        this.mContext = context;        this.databasePath = context.getDatabasePath(DB_NAME);        try {            this.createEmptyDataBase();        } catch (IOException ioe) {            throw new Error("Unable to create database");        } catch(SQLException sqle){            throw sqle;        }    }    /**     * asset に格納したデータベースをコピーするための空のデータベースを作成する     *     **/    public void createEmptyDataBase() throws IOException{        boolean dbExist = checkDataBaseExists();        if(dbExist){            // すでにデータベースは作成されている        }else{            // このメソッドを呼ぶことで、空のデータベースが            // アプリのデフォルトシステムパスに作られる            this.getWritableDatabase();            try {                // asset に格納したデータベースをコピーする                copyDataBaseFromAsset();            } catch (IOException e){                throw new Error("Error copying database");            }        }    }    /**     * 再コピーを防止するために、すでにデータベースがあるかどうか判定する     *     * @return 存在している場合 {@code true}     */    private boolean checkDataBaseExists() {        SQLiteDatabase checkDb = null;        try{            String dbPath = databasePath.getPath();            checkDb = SQLiteDatabase.openDatabase(dbPath, null,SQLiteDatabase.NO_LOCALIZED_COLLATORS | SQLiteDatabase.OPEN_READWRITE);        }catch(SQLiteException e){            // データベースはまだ存在していない        }        if(checkDb != null){            checkDb.close();        }        return checkDb != null ? true : false;    }    /**     * asset に格納したデーだベースをデフォルトの     * データベースパスに作成したからのデータベースにコピーする     * */    private void copyDataBaseFromAsset() throws IOException{        // asset 内のデータベースファイルにアクセス        InputStream mInput = mContext.getAssets().open(DB_NAME_ASSET);        OutputStream mOutput = new FileOutputStream(databasePath);        // コピー        byte[] buffer = new byte[1024];        int size;        while ((size = mInput.read(buffer)) > 0){            mOutput.write(buffer, 0, size);        }        //Close the streams        mOutput.flush();        mOutput.close();        mInput.close();    }    public SQLiteDatabase openDataBase() throws SQLException{        //Open the database        String myPath = databasePath.getPath();        SQLiteDatabase dataBase = SQLiteDatabase.openDatabase(myPath, null,SQLiteDatabase.NO_LOCALIZED_COLLATORS | SQLiteDatabase.OPEN_READWRITE);        return dataBase;    }    @Override    public void onCreate(SQLiteDatabase arg0) {    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }
    
     //全件取得    public ArrayList getAllUsers(){        SQLiteDatabase db = this.openDataBase();        Cursor cur = db.rawQuery("SELECT * FROM user_data;",null);        ArrayList array = new ArrayList();        cur.moveToFirst();        for (int i = 0; i < cur.getCount(); i++){            ArrayList list = new ArrayList();            //0            String str = cur.getString(cur.getColumnIndex("name"));            //中身がnullなら空文字を入れる            if(str == null){                list.add("");            }else{                list.add(str);            }            //1            list.add(cur.getInt(cur.getColumnIndex("rank")));            //2            list.add(cur.getInt(cur.getColumnIndex("exp")));            //3            list.add(cur.getInt(cur.getColumnIndex("max_stamina")));            //4            list.add(cur.getInt(cur.getColumnIndex("stamina")));            //5            list.add(cur.getInt(cur.getColumnIndex("exp_char")));            //6            list.add(cur.getInt(cur.getColumnIndex("dia_num")));            //7            list.add(cur.getInt(cur.getColumnIndex("all_cost")));            //8            list.add(cur.getInt(cur.getColumnIndex("deckNum")));            //9            list.add(cur.getInt(cur.getColumnIndex("mile")));            //10            list.add(cur.getInt(cur.getColumnIndex("region_id")));            //11            list.add(cur.getInt(cur.getColumnIndex("image_id")));            array.add(list);            cur.moveToNext();        }        cur.close();        db.close();        return array;    }    //取得    public int getUserStamina(){        SQLiteDatabase db = this.openDataBase();        Cursor cur = db.rawQuery("SELECT stamina FROM user_data",null);        cur.moveToFirst();        int stamina = 0;        if(cur.getCount() > 0){            stamina=cur.getInt(cur.getColumnIndex("stamina"));        }        cur.close();        db.close();        return stamina;    }    更新    public void updateBattleEffect(int identifer,int num){        String sql = "UPDATE battle_effects SET num = ? WHERE id = ?";        SQLiteDatabase db = getWritableDatabase();        try {            db.execSQL(sql,new String[]	
            {String.valueOf(num),String.valueOf(identifer)});        }catch (SQLException e){            Log.d("sqliteException","Error");        } finally {            db.close();        }    }     //削除    public void removePresentById(int identifier){        String sql = "DELETE FROM saved_present WHERE saved_presentid = ?";        SQLiteDatabase db = getWritableDatabase();        try {            db.execSQL(sql,new String[]{String.valueOf(identifier)});        }catch (SQLException e){            Log.d("sqliteException","Error");        } finally {            db.close();        }    }    
		//レコード作成     public void addNewRewardRecordByAchieveId( String achieveId,int point){        long date = System.currentTimeMillis();        String sql = "INSERT INTO reward_record (achieve_id, point, date) VALUES (?,?,?)";        SQLiteDatabase db = getWritableDatabase();        try {            db.execSQL(sql,new String[]{achieveId,String.valueOf(point),String.valueOf(date)});        }catch (SQLException e){            Log.d("sqliteException","Error");        } finally {            db.close();        }    }